<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Damage Live Visualizer</title>
  <style>
    :root {
      --bg: #f4efe6;
      --ink: #132522;
      --muted: #48615d;
      --accent: #bf3f2f;
      --accent-2: #1b7f79;
      --card: #fffbf3;
      --line: #d8c8b6;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Space Grotesk", "Avenir Next", "Segoe UI", sans-serif;
      color: var(--ink);
      background:
        radial-gradient(circle at 10% 10%, #ffcf9d 0%, transparent 30%),
        radial-gradient(circle at 90% 0%, #8dd2cc 0%, transparent 30%),
        var(--bg);
    }
    .wrap { max-width: 1320px; margin: 0 auto; padding: 18px; }
    .top {
      display: grid;
      grid-template-columns: 1fr auto auto auto auto auto;
      gap: 8px;
      align-items: center;
      margin-bottom: 14px;
    }
    select, button {
      height: 38px;
      border: 1px solid var(--line);
      background: var(--card);
      color: var(--ink);
      border-radius: 8px;
      padding: 0 12px;
      font: inherit;
    }
    button {
      cursor: pointer;
      background: linear-gradient(120deg, var(--accent), #d96a49);
      color: #fff;
      border: none;
      transition: transform .12s ease;
    }
    button:hover { transform: translateY(-1px); }
    .grid {
      display: grid;
      grid-template-columns: 1.2fr 1fr 1fr;
      gap: 12px;
    }
    .panel {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 12px;
      min-height: 280px;
    }
    .panel h3 {
      margin: 0 0 8px 0;
      font-size: 15px;
      letter-spacing: .04em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      font-size: 12px;
      background: #e9f2f1;
      color: #16403c;
      margin-left: 8px;
    }
    .thinking {
      background: #ffe4ba;
      color: #7a3f00;
      animation: pulse 1s ease-in-out infinite;
    }
    @keyframes pulse {
      0% { opacity: 0.7; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }
    .table {
      font-family: "IBM Plex Mono", "Consolas", monospace;
      border: 1px solid #e7dac7;
      border-radius: 8px;
      padding: 8px;
      background: #fffef9;
      margin-bottom: 10px;
      white-space: pre-wrap;
    }
    .player {
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid #ecdfcf;
    }
    .cards { font-family: "IBM Plex Mono", "Consolas", monospace; font-size: 12px; color: #2f4441; }
    .emotion-row {
      display: grid;
      grid-template-columns: 88px 1fr 40px;
      align-items: center;
      gap: 6px;
      margin: 4px 0;
      font-size: 12px;
    }
    .bar {
      height: 9px;
      background: #f0e6d8;
      border-radius: 999px;
      overflow: hidden;
    }
    .bar > div {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-2), #6cc6b8);
      width: 0;
    }
    .event-feed {
      font-family: "IBM Plex Mono", "Consolas", monospace;
      font-size: 12px;
      overflow: auto;
      border: 1px dashed var(--line);
      border-radius: 8px;
      padding: 8px;
      background: #fffdf8;
      flex: 1 1 auto;
      min-height: 240px;
    }
    #eventPanel {
      display: flex;
      flex-direction: column;
    }
    .event { margin-bottom: 6px; padding-bottom: 6px; border-bottom: 1px solid #eee2d3; }
    .event:last-of-type { margin-bottom: 0; }
    .event pre {
      margin: 4px 0 0;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .j-key { color: #0c5e57; font-weight: 600; }
    .j-str { color: #904314; }
    .j-num { color: #255aa8; }
    .j-bool { color: #7a2f84; }
    .j-null { color: #666; font-style: italic; }
    .meta { color: var(--muted); font-size: 11px; }
    .token {
      margin-top: 6px;
      padding: 8px;
      border-radius: 8px;
      background: #eef7f6;
      font-size: 12px;
      white-space: pre-wrap;
      font-family: "IBM Plex Mono", "Consolas", monospace;
    }
    .timeline {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
    }
    .timeline input[type="range"] {
      width: 100%;
    }
    .mini {
      font-family: "IBM Plex Mono", "Consolas", monospace;
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }
    @media (max-width: 980px) {
      .top { grid-template-columns: 1fr 1fr; }
      .grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <select id="games"></select>
      <button id="refresh">Refresh Games</button>
      <button id="replay">Load Replay</button>
      <button id="live">Live Stream</button>
      <button id="prev">Prev</button>
      <button id="next">Next</button>
    </div>
    <div class="timeline">
      <input id="cursor" type="range" min="0" max="0" value="0">
      <button id="play">Play</button>
    </div>
    <div class="mini" id="cursorLabel">event 0 / 0</div>
    <div class="grid">
      <div class="panel">
        <h3>Table <span id="gameLabel" class="badge">none</span></h3>
        <div id="table" class="table">No hand loaded.</div>
        <div id="players"></div>
      </div>
      <div class="panel">
        <h3>Token Monitor</h3>
        <div id="tokens" class="token">No data yet.</div>
      </div>
      <div class="panel" id="eventPanel">
        <h3>Event Feed</h3>
        <div id="events" class="event-feed"></div>
      </div>
    </div>
  </div>

  <script>
    const state = {
      gameId: null,
      turn: 0,
      pot: 0,
      highBet: 0,
      winners: [],
      players: {},
      events: [],
      source: null,
      replayEvents: [],
      cursor: 0,
      playing: false,
      playTimer: null
    };

    const EMOTIONS = ["fear", "anger", "shame", "confidence", "tilt"];

    const el = {
      games: document.getElementById("games"),
      gameLabel: document.getElementById("gameLabel"),
      table: document.getElementById("table"),
      players: document.getElementById("players"),
      tokens: document.getElementById("tokens"),
      events: document.getElementById("events"),
      cursor: document.getElementById("cursor"),
      cursorLabel: document.getElementById("cursorLabel"),
      prev: document.getElementById("prev"),
      next: document.getElementById("next"),
      play: document.getElementById("play"),
      refresh: document.getElementById("refresh"),
      replay: document.getElementById("replay"),
      live: document.getElementById("live")
    };

    function initPlayer(id) {
      if (!state.players[id]) {
        state.players[id] = {
          lives: 3,
          bankroll: 200,
          current_bet: 0,
          in_hand: true,
          will: 60,
          skill_affect: 55,
          focus: 100,
          stress: 0,
          resistance_bonus: 0,
          thinking: false,
          thought: "",
          hand: [],
          tempo: 0,
          exposure: 0,
          emotions: { fear: 0, anger: 0, shame: 0, confidence: 0, tilt: 0 }
        };
      }
      return state.players[id];
    }

    function applyPlayerSnapshot(p) {
      const x = initPlayer(p.player_id);
      x.lives = Number(p.lives ?? x.lives);
      x.bankroll = Number(p.bankroll ?? x.bankroll);
      x.current_bet = Number(p.current_bet ?? x.current_bet);
      x.in_hand = Boolean(p.in_hand ?? x.in_hand);
      x.will = Number(p.will ?? x.will);
      x.skill_affect = Number(p.skill_affect ?? x.skill_affect);
      x.focus = Number(p.focus ?? x.focus);
      x.stress = Number(p.stress ?? x.stress);
      x.resistance_bonus = Number(p.resistance_bonus ?? x.resistance_bonus);
      x.thinking = Boolean(p.thinking ?? x.thinking);
      x.hand = p.hand || x.hand;
      x.tempo = Number(p.tempo ?? x.tempo);
      x.exposure = Number(p.exposure ?? x.exposure);
      x.emotions = p.emotions || x.emotions;
    }

    function applyEvent(evt) {
      state.events.push(evt);
      const t = evt.type;
      const p = evt.payload || {};

      if (typeof p.turn === "number") state.turn = p.turn;
      if (typeof p.pot === "number") state.pot = p.pot;
      if (typeof p.current_high_bet === "number") state.highBet = p.current_high_bet;

      if (t === "game_started") {
        state.players = {};
        const n = p.players || 0;
        for (let i = 1; i <= n; i++) initPlayer("P" + i);
      }
      if (t === "hand_started") {
        (p.players || []).forEach(applyPlayerSnapshot);
      }
      if (t === "action_resolved") {
        if (p.player_state) applyPlayerSnapshot(p.player_state);
      }
      if (t === "thinking") {
        const pid = p.player_id;
        if (pid) {
          const pl = initPlayer(pid);
          pl.thinking = p.status === "start";
          if (typeof p.summary === "string" && p.summary.trim()) {
            pl.thought = p.summary.trim();
          }
        }
      }
      if (t === "life_lost" || t === "player_eliminated") {
        const pid = p.player_id;
        if (pid) initPlayer(pid).lives = Number(p.remaining_lives ?? initPlayer(pid).lives);
      }
      if (t === "showdown") {
        state.winners = p.winners || [];
        const rankings = p.rankings || {};
        Object.entries(rankings).forEach(([pid, info]) => {
          initPlayer(pid).hand = info.hand || initPlayer(pid).hand;
        });
      }
      if (t === "hand_ended") {
        (p.players || []).forEach(applyPlayerSnapshot);
      }
      if (t === "game_ended") {
        const finalState = p.final_state || [];
        finalState.forEach(applyPlayerSnapshot);
      }
      if (t === "turn_summary") {
        const ts = p.token_stats || {};
        const byModel = p.token_stats_by_model || {};
        const modelRows = Object.entries(byModel).map(([k, v]) =>
          `${k}: calls=${v.calls}, avg=${v.avg_total.toFixed(1)}, req_ctx=${v.required_context_capacity.toFixed(0)}`
        );
        el.tokens.textContent =
          `calls=${ts.calls || 0}, avg_total=${(ts.avg_total || 0).toFixed(1)}, p95=${(ts.p95_total || 0).toFixed(1)}, required_ctx=${(ts.required_context_capacity || 0).toFixed(0)}\n` +
          modelRows.join("\n") +
          (p.context_warning ? `\nwarning=${p.context_warning}` : "");
      }
    }

    function pctEmotion(v) {
      const n = Number(v || 0);
      return Math.max(0, Math.min(100, (n + 1) * 50));
    }

    function renderPlayers() {
      const ids = Object.keys(state.players).sort();
      if (!ids.length) {
        el.players.innerHTML = "<div>No player data yet.</div>";
        return;
      }
      const rows = ids.map(pid => {
        const p = state.players[pid];
        const emoRows = EMOTIONS.map((k) => {
          const v = Number(p.emotions?.[k] || 0);
          return `
            <div class="emotion-row">
              <span>${k}</span>
              <div class="bar"><div style="width:${pctEmotion(v)}%;background:${k === "fear" ? "linear-gradient(90deg,#bf3f2f,#ef8a6d)" : "linear-gradient(90deg,#1b7f79,#6cc6b8)"}"></div></div>
              <span>${v.toFixed(2)}</span>
            </div>`;
        }).join("");
        const winnerBadge = state.winners.includes(pid) ? " <span class='badge'>winner</span>" : "";
        const thinkingBadge = p.thinking ? " <span class='badge thinking'>thinking...</span>" : "";
        return `
          <div class="player">
            <div><strong>${pid}</strong>${winnerBadge}${thinkingBadge} lives=${p.lives} bankroll=${p.bankroll} bet=${p.current_bet} in_hand=${p.in_hand}</div>
            <div class="cards">will=${p.will} skill=${p.skill_affect} focus=${p.focus.toFixed(1)} stress=${p.stress.toFixed(1)} resist=${p.resistance_bonus.toFixed(1)}</div>
            <div class="cards">thought: ${p.thought || "-"}</div>
            <div class="cards">cards: ${(p.hand || []).join(" ") || "-"}</div>
            ${emoRows}
          </div>
        `;
      }).join("");
      el.players.innerHTML = rows;
    }

    function renderTable() {
      el.table.textContent = `turn=${state.turn}\npot=${state.pot}\nhigh_bet=${state.highBet}\nwinners=${state.winners.join(",") || "-"}`;
    }

    function renderEvents() {
      const tail = state.events.slice(-150);
      const colorize = (obj) => {
        const escaped = JSON.stringify(obj || {}, null, 2)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
        return escaped.replace(
          /("(?:\\u[a-fA-F0-9]{4}|\\[^u]|[^\\"])*"(?=:))|("(?:\\u[a-fA-F0-9]{4}|\\[^u]|[^\\"])*")|(\b-?\d+(?:\.\d+)?(?:[eE][+\-]?\d+)?\b)|(\btrue\b|\bfalse\b)|(\bnull\b)/g,
          (m, key, str, num, bool, nll) => {
            if (key) return `<span class="j-key">${key}</span>`;
            if (str) return `<span class="j-str">${str}</span>`;
            if (num) return `<span class="j-num">${num}</span>`;
            if (bool) return `<span class="j-bool">${bool}</span>`;
            if (nll) return `<span class="j-null">${nll}</span>`;
            return m;
          }
        );
      };
      el.events.innerHTML = tail.map((evt) => {
        const payload = colorize(evt.payload || {});
        return `<div class="event"><div><strong>${evt.type}</strong></div><div class="meta">${evt.ts || ""}</div><pre>${payload}</pre></div>`;
      }).join("");
      el.events.scrollTop = el.events.scrollHeight;
    }

    function refreshView() {
      el.gameLabel.textContent = state.gameId || "none";
      const total = state.replayEvents.length;
      el.cursor.max = String(Math.max(0, total));
      el.cursor.value = String(state.cursor);
      el.cursorLabel.textContent = `event ${state.cursor} / ${total}`;
      el.play.textContent = state.playing ? "Pause" : "Play";
      renderTable();
      renderPlayers();
      renderEvents();
    }

    function resetDerivedState() {
      state.turn = 0;
      state.pot = 0;
      state.highBet = 0;
      state.winners = [];
      state.players = {};
      state.events = [];
    }

    function seekReplay(cursor) {
      state.cursor = Math.max(0, Math.min(cursor, state.replayEvents.length));
      resetDerivedState();
      for (let i = 0; i < state.cursor; i++) {
        applyEvent(state.replayEvents[i]);
      }
      refreshView();
    }

    function stopPlayback() {
      state.playing = false;
      if (state.playTimer) {
        clearInterval(state.playTimer);
        state.playTimer = null;
      }
    }

    function startPlayback() {
      if (state.playing) return;
      state.playing = true;
      state.playTimer = setInterval(() => {
        if (state.cursor >= state.replayEvents.length) {
          stopPlayback();
          refreshView();
          return;
        }
        seekReplay(state.cursor + 1);
      }, 420);
      refreshView();
    }

    async function loadGames() {
      const r = await fetch("/api/games");
      const data = await r.json();
      const games = data.games || [];
      el.games.innerHTML = games.map(g => `<option value="${g.game_id}">${g.game_id} (${g.event_count})</option>`).join("");
      if (games.length && !state.gameId) state.gameId = games[0].game_id;
      if (state.gameId) el.games.value = state.gameId;
      refreshView();
    }

    async function loadReplay() {
      state.gameId = el.games.value;
      stopPlayback();
      resetDerivedState();
      if (state.source) { state.source.close(); state.source = null; }
      const r = await fetch(`/api/replay?game_id=${encodeURIComponent(state.gameId)}`);
      const data = await r.json();
      state.replayEvents = data.events || [];
      seekReplay(state.replayEvents.length);
    }

    function startLive() {
      state.gameId = el.games.value;
      stopPlayback();
      resetDerivedState();
      state.replayEvents = [];
      state.cursor = 0;
      if (state.source) state.source.close();
      state.source = new EventSource(`/api/stream?game_id=${encodeURIComponent(state.gameId)}`);
      state.source.onmessage = (msg) => {
        const evt = JSON.parse(msg.data);
        state.cursor += 1;
        applyEvent(evt);
        refreshView();
      };
      state.source.onerror = () => {};
      refreshView();
    }

    el.refresh.addEventListener("click", loadGames);
    el.replay.addEventListener("click", loadReplay);
    el.live.addEventListener("click", startLive);
    el.prev.addEventListener("click", () => { stopPlayback(); seekReplay(state.cursor - 1); });
    el.next.addEventListener("click", () => { stopPlayback(); seekReplay(state.cursor + 1); });
    el.play.addEventListener("click", () => {
      if (state.playing) stopPlayback(); else startPlayback();
      refreshView();
    });
    el.cursor.addEventListener("input", () => {
      stopPlayback();
      seekReplay(Number(el.cursor.value));
    });
    el.games.addEventListener("change", () => { state.gameId = el.games.value; refreshView(); });
    loadGames();
  </script>
</body>
</html>
