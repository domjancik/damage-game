<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Damage 3D Arena Preview</title>
  <style>
    :root {
      --bg: #efe6da;
      --ink: #172621;
      --panel: #fff9ef;
      --line: #ccb9a3;
      --accent: #cf5a37;
      --muted: #58716b;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      color: var(--ink);
      font-family: "Space Grotesk", "Avenir Next", "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at 12% 10%, #ffd3a6 0%, transparent 30%),
        radial-gradient(circle at 84% 8%, #a6ded5 0%, transparent 30%),
        var(--bg);
    }
    .wrap { max-width: 1400px; margin: 0 auto; padding: 14px; }
    .top {
      display: grid;
      grid-template-columns: 1fr auto auto auto auto;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
    }
    select, button, input[type="range"] {
      height: 38px;
      border-radius: 8px;
      border: 1px solid var(--line);
      font: inherit;
      padding: 0 10px;
      background: var(--panel);
      color: var(--ink);
    }
    button {
      cursor: pointer;
      border: none;
      color: #fff;
      background: linear-gradient(120deg, var(--accent), #e07b52);
    }
    .grid {
      display: grid;
      grid-template-columns: 1.6fr 1fr;
      gap: 12px;
    }
    .panel {
      border: 1px solid var(--line);
      border-radius: 12px;
      background: var(--panel);
      padding: 10px;
      min-height: 720px;
    }
    #stage {
      width: 100%;
      height: 700px;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid #d8c8b6;
      background: #ede7da;
    }
    .meta {
      font-family: "IBM Plex Mono", "Consolas", monospace;
      font-size: 12px;
      color: var(--muted);
      margin-top: 8px;
      display: grid;
      grid-template-columns: 1fr auto;
    }
    .list {
      height: 700px;
      overflow: auto;
      font-family: "IBM Plex Mono", "Consolas", monospace;
      font-size: 12px;
      border: 1px dashed var(--line);
      border-radius: 8px;
      padding: 8px;
      background: #fffdf8;
    }
    .row {
      border-bottom: 1px solid #f1e5d8;
      margin-bottom: 6px;
      padding-bottom: 6px;
    }
    .chips {
      display: inline-block;
      padding: 1px 6px;
      border-radius: 999px;
      background: #fde4be;
      color: #5f3902;
      margin-left: 4px;
    }
    .home {
      color: var(--muted);
      font-size: 12px;
      margin-left: 4px;
    }
    @media (max-width: 1080px) {
      .top { grid-template-columns: 1fr 1fr; }
      .grid { grid-template-columns: 1fr; }
      .panel { min-height: 520px; }
      #stage, .list { height: 500px; }
    }
  </style>
  <script>
    window.addEventListener("error", (evt) => {
      const box = document.createElement("div");
      box.style.position = "fixed";
      box.style.left = "12px";
      box.style.bottom = "12px";
      box.style.zIndex = "9999";
      box.style.maxWidth = "70vw";
      box.style.padding = "10px 12px";
      box.style.borderRadius = "8px";
      box.style.border = "1px solid #d79d8f";
      box.style.background = "#fff1ed";
      box.style.color = "#6b1d0b";
      box.style.font = "12px monospace";
      box.textContent = `arena render error: ${evt.message || "unknown"}`;
      document.body.appendChild(box);
    });
  </script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.164.1/build/three.module.js"
      }
    }
  </script>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <select id="focus"></select>
      <button id="refresh">Refresh</button>
      <button id="auto">Auto: on</button>
      <label><input id="liveOnly" type="checkbox"> Live Tables Only</label>
      <label>Scale <input id="scale" type="range" min="70" max="170" value="110"></label>
      <a class="home" href="/">dashboard</a>
    </div>
    <div class="grid">
      <div class="panel">
        <div id="stage"></div>
        <div class="meta">
          <span id="summary">loading...</span>
          <span>3D arena preview (stake pyramid)</span>
        </div>
      </div>
      <div class="panel">
        <div class="list" id="tables"></div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "https://unpkg.com/three@0.164.1/examples/jsm/controls/OrbitControls.js";

    const AVATAR_COLORS = {
      pilot_ace: "#d95f43",
      stoic_oracle: "#5984c7",
      bluff_knight: "#59a57a",
      cold_mirror: "#886cc5",
      trickster: "#cb8d34",
      iron_reader: "#48929a",
      quiet_storm: "#ce4f74",
      vector_hawk: "#6e8b3f",
      default: "#777f91"
    };

    const state = {
      tables: [],
      auto: true,
      autoTimer: null,
      focusTable: "__all__",
      worldScale: 1.1,
      liveOnly: false
    };

    const el = {
      stage: document.getElementById("stage"),
      tables: document.getElementById("tables"),
      summary: document.getElementById("summary"),
      refresh: document.getElementById("refresh"),
      auto: document.getElementById("auto"),
      liveOnly: document.getElementById("liveOnly"),
      focus: document.getElementById("focus"),
      scale: document.getElementById("scale")
    };

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(el.stage.clientWidth, el.stage.clientHeight);
    renderer.shadowMap.enabled = true;
    el.stage.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color("#ede7da");
    scene.fog = new THREE.Fog("#ede7da", 30, 90);

    const camera = new THREE.PerspectiveCamera(45, el.stage.clientWidth / el.stage.clientHeight, 0.1, 220);
    camera.position.set(12, 18, 24);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxDistance = 80;
    controls.minDistance = 8;
    controls.target.set(0, 2, 0);

    const hemi = new THREE.HemisphereLight("#fff5df", "#8ca7a1", 0.85);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight("#fff9ec", 0.95);
    dir.position.set(10, 18, 6);
    dir.castShadow = true;
    scene.add(dir);

    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(140, 140, 1, 1),
      new THREE.MeshStandardMaterial({ color: "#d8cfbf", roughness: 0.95 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    const tableLayer = new THREE.Group();
    scene.add(tableLayer);
    const cardTextureCache = new Map();

    function dominantEmotion(em) {
      const base = em || {};
      const items = [
        ["fear", Number(base.fear || 0)],
        ["anger", Number(base.anger || 0)],
        ["shame", Number(base.shame || 0)],
        ["confidence", Number(base.confidence || 0)],
        ["tilt", Number(base.tilt || 0)],
      ];
      items.sort((a, b) => Math.abs(b[1]) - Math.abs(a[1]));
      return items[0];
    }

    function mapSeatCount(playerCount) {
      return playerCount <= 6 ? 6 : 8;
    }

    function parseGameEvents(gameId, events) {
      const table = {
        gameId,
        turn: 0,
        phase: "idle",
        ante: 10,
        pot: 0,
        highBet: 0,
        seatCount: 6,
        players: {},
        winners: [],
        status: "active",
        stakeValue: 10,
        cardStyle: "draw5",
        communityCards: [],
      };
      for (const evt of (events || [])) {
        const p = evt.payload || {};
        if (evt.type === "game_started") {
          table.seatCount = mapSeatCount(Number(p.players || 0));
        }
        if (typeof p.turn === "number") table.turn = p.turn;
        if (typeof p.card_style === "string") table.cardStyle = p.card_style;
        if (Array.isArray(p.community_cards)) table.communityCards = p.community_cards.slice();
        if (evt.type === "phase_changed") table.phase = String(p.phase || table.phase);
        if (evt.type === "hand_started") {
          table.ante = Number(p.ante || table.ante);
          table.pot = Number(p.pot || table.pot);
          for (const pl of (p.players || [])) {
            table.players[pl.player_id] = {
              ...(table.players[pl.player_id] || {}),
              ...pl,
              thinking: false,
              thought: (table.players[pl.player_id] || {}).thought || "",
              avatar_id: pl.avatar_id || (table.players[pl.player_id] || {}).avatar_id || "pilot_ace",
            };
          }
        }
        if (evt.type === "action_resolved" && p.player_state && p.player_id) {
          table.pot = Number(p.pot || table.pot);
          table.highBet = Number(p.current_high_bet || table.highBet);
          table.players[p.player_id] = {
            ...(table.players[p.player_id] || {}),
            ...p.player_state,
            thinking: (table.players[p.player_id] || {}).thinking || false,
            thought: (table.players[p.player_id] || {}).thought || "",
            avatar_id: p.player_state.avatar_id || (table.players[p.player_id] || {}).avatar_id || "pilot_ace",
          };
        }
        if (evt.type === "avatar_selected" && p.player_id) {
          table.players[p.player_id] = {
            ...(table.players[p.player_id] || { player_id: p.player_id }),
            avatar_id: String(p.avatar_id || "pilot_ace"),
          };
        }
        if (evt.type === "thinking" && p.player_id) {
          table.players[p.player_id] = {
            ...(table.players[p.player_id] || { player_id: p.player_id }),
            thinking: p.status === "start",
            thought: typeof p.summary === "string" && p.summary.trim()
              ? p.summary.trim()
              : (table.players[p.player_id] || {}).thought || "",
          };
        }
        if (evt.type === "showdown") {
          table.winners = Array.isArray(p.winners) ? p.winners : [];
          table.pot = Number(p.pot || table.pot);
        }
        if (evt.type === "hand_ended") {
          for (const pl of (p.players || [])) {
            table.players[pl.player_id] = {
              ...(table.players[pl.player_id] || {}),
              ...pl,
              thinking: (table.players[pl.player_id] || {}).thinking || false,
              thought: (table.players[pl.player_id] || {}).thought || "",
              avatar_id: pl.avatar_id || (table.players[pl.player_id] || {}).avatar_id || "pilot_ace",
            };
          }
        }
        if (evt.type === "game_ended") {
          table.status = "ended";
          for (const pl of (p.final_state || [])) {
            table.players[pl.player_id] = {
              ...(table.players[pl.player_id] || {}),
              ...pl,
              avatar_id: pl.avatar_id || (table.players[pl.player_id] || {}).avatar_id || "pilot_ace",
            };
          }
        }
      }
      const playersArr = Object.values(table.players);
      const playerCount = playersArr.length;
      if (playerCount > 0) {
        table.seatCount = mapSeatCount(playerCount);
      }
      const anteStake = Math.max(1, table.ante * Math.max(1, playerCount));
      table.stakeValue = Math.max(anteStake, table.pot, table.highBet * Math.max(1, playerCount), 10);
      return table;
    }

    async function loadArenaData() {
      const gamesRes = await fetch("/api/games");
      const gamesData = await gamesRes.json();
      const games = Array.isArray(gamesData.games) ? gamesData.games : [];
      const sliced = games.slice(0, 24);
      const replays = await Promise.all(
        sliced.map(async (g) => {
          try {
            const r = await fetch(`/api/replay?game_id=${encodeURIComponent(g.game_id)}`);
            const data = await r.json();
            return parseGameEvents(g.game_id, data.events || []);
          } catch {
            return null;
          }
        })
      );
      state.tables = replays.filter(Boolean);
      renderTableList();
      rebuildFocusOptions();
      render3D();
    }

    function buildLabelTexture(lines) {
      const canvas = document.createElement("canvas");
      canvas.width = 256;
      canvas.height = 128;
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "rgba(255, 251, 240, 0.92)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "rgba(66, 50, 38, 0.45)";
      ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
      ctx.fillStyle = "#1c2d28";
      ctx.font = "18px monospace";
      for (let i = 0; i < lines.length; i++) {
        ctx.fillText(lines[i], 12, 26 + i * 22);
      }
      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;
      return tex;
    }

    function parseCardCode(code) {
      const text = String(code || "").trim().toUpperCase();
      if (text.length < 2) return { rank: "?", suit: "?" };
      return { rank: text.slice(0, -1), suit: text.slice(-1) };
    }

    function suitVisual(suit) {
      if (suit === "H") return { symbol: "♥", color: "#c13f36" };
      if (suit === "D") return { symbol: "♦", color: "#cf5a37" };
      if (suit === "S") return { symbol: "♠", color: "#1f2d39" };
      return { symbol: "♣", color: "#1f5f41" };
    }

    function cardTexture(cardCode) {
      const key = String(cardCode || "??");
      if (cardTextureCache.has(key)) return cardTextureCache.get(key);
      const { rank, suit } = parseCardCode(key);
      const suitMeta = suitVisual(suit);
      const canvas = document.createElement("canvas");
      canvas.width = 160;
      canvas.height = 224;
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "#fffdf6";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#d3c3ad";
      ctx.lineWidth = 5;
      ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
      ctx.fillStyle = suitMeta.color;
      ctx.font = "bold 38px monospace";
      ctx.fillText(rank, 14, 42);
      ctx.font = "bold 36px monospace";
      ctx.fillText(suitMeta.symbol, 18, 78);
      ctx.font = "bold 84px monospace";
      ctx.fillText(suitMeta.symbol, 56, 146);
      ctx.font = "bold 34px monospace";
      ctx.fillText(rank, canvas.width - 38, canvas.height - 16);
      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;
      tex.anisotropy = 2;
      cardTextureCache.set(key, tex);
      return tex;
    }

    function seatPosition(index, total, radius) {
      const angle = (-Math.PI / 2) + (2 * Math.PI * index / Math.max(total, 1));
      return new THREE.Vector3(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
    }

    function allocateTierCounts(total, tierCount) {
      const t = Math.max(1, Math.min(total, tierCount));
      const weights = [];
      for (let i = 0; i < t; i++) {
        weights.push(Math.pow(2, t - 1 - i));
      }
      const sumW = weights.reduce((a, b) => a + b, 0);
      const counts = weights.map((w) => Math.max(1, Math.floor((w / sumW) * total)));
      let current = counts.reduce((a, b) => a + b, 0);
      while (current < total) {
        for (let i = 0; i < counts.length && current < total; i++) {
          counts[i] += 1;
          current += 1;
        }
      }
      while (current > total) {
        for (let i = counts.length - 1; i >= 0 && current > total; i--) {
          if (counts[i] > 1) {
            counts[i] -= 1;
            current -= 1;
          }
        }
      }
      return counts;
    }

    function render3D() {
      while (tableLayer.children.length) {
        const c = tableLayer.children.pop();
        c.traverse((node) => {
          if (node.geometry) node.geometry.dispose();
          if (node.material) {
            if (Array.isArray(node.material)) node.material.forEach((m) => m.dispose());
            else node.material.dispose();
          }
        });
      }

      const list = state.tables.filter((t) => {
        if (state.liveOnly && t.status !== "active") return false;
        return state.focusTable === "__all__" || t.gameId === state.focusTable;
      });
      const sortedByStake = list
        .slice()
        .sort((a, b) => Number(a.stakeValue || 0) - Number(b.stakeValue || 0));
      const tierCount = Math.max(1, Math.min(5, Math.ceil(Math.log2(Math.max(2, sortedByStake.length)))));
      const tierCounts = allocateTierCounts(sortedByStake.length, tierCount);
      const tiers = [];
      let cursor = 0;
      for (let i = 0; i < tierCounts.length; i++) {
        const take = tierCounts[i];
        tiers.push(sortedByStake.slice(cursor, cursor + take));
        cursor += take;
      }
      const spacingX = 12 * state.worldScale;
      const spacingZ = 11 * state.worldScale;

      tiers.forEach((tierTables, tierIndex) => {
        const tierY = 0.5 + tierIndex * 1.8 * state.worldScale;
        const tierZ = (tiers.length - 1 - tierIndex) * spacingZ - ((tiers.length - 1) * spacingZ * 0.5);
        const cols = Math.max(1, Math.ceil(Math.sqrt(tierTables.length * 1.8)));
        const rows = Math.max(1, Math.ceil(tierTables.length / cols));
        tierTables.forEach((t, localIndex) => {
          const group = new THREE.Group();
          const col = localIndex % cols;
          const row = Math.floor(localIndex / cols);
          const centeredX = (col - (cols - 1) / 2) * spacingX;
          const centeredZ = tierZ + (row - (rows - 1) / 2) * (spacingZ * 0.7);
          group.position.set(centeredX, tierY, centeredZ);

          const tableBase = new THREE.Mesh(
            new THREE.CylinderGeometry(4.5, 5.0, 1.1, 36),
            new THREE.MeshStandardMaterial({ color: "#244e45", roughness: 0.65 })
          );
          tableBase.castShadow = true;
          group.add(tableBase);

          const felt = new THREE.Mesh(
            new THREE.CylinderGeometry(4.1, 4.1, 0.14, 32),
            new THREE.MeshStandardMaterial({ color: "#2f8d75", roughness: 0.75 })
          );
          felt.position.y = 0.62;
          group.add(felt);

          const infoSprite = new THREE.Sprite(
            new THREE.SpriteMaterial({ map: buildLabelTexture([
              t.gameId,
              `pot=${t.pot} ante=${t.ante}`,
              `turn=${t.turn} phase=${t.phase} style=${t.cardStyle}`,
              `tier=${tierIndex + 1}/${tiers.length} stake=${Math.round(t.stakeValue)}`,
            ]) })
          );
          infoSprite.scale.set(5.0, 2.5, 1);
          infoSprite.position.set(0, 3.6, 0);
          group.add(infoSprite);

          const ids = Object.keys(t.players).sort();
          for (let seat = 0; seat < t.seatCount; seat++) {
            const pos = seatPosition(seat, t.seatCount, 5.4);
            const chair = new THREE.Mesh(
              new THREE.CylinderGeometry(0.45, 0.45, 0.35, 20),
              new THREE.MeshStandardMaterial({ color: "#6b4a34", roughness: 0.85 })
            );
            chair.position.copy(pos);
            chair.position.y = 0.25;
            group.add(chair);

            const pid = ids[seat] || null;
            if (!pid) continue;
            const pl = t.players[pid] || {};
            const avatarId = String(pl.avatar_id || "pilot_ace");
            const bodyColor = AVATAR_COLORS[avatarId] || AVATAR_COLORS.default;
            const [dominant, emoVal] = dominantEmotion(pl.emotions || {});
            const intensity = Math.max(0.15, Math.min(1.0, Math.abs(Number(emoVal || 0))));
            const headColor = dominant === "confidence" ? "#c7f0cc" :
              dominant === "anger" ? "#f0b4a8" :
              dominant === "fear" ? "#d8e5f0" :
              dominant === "tilt" ? "#f3d2a6" : "#e2d8f4";

            const body = new THREE.Mesh(
              new THREE.CapsuleGeometry(0.28, 0.6, 4, 8),
              new THREE.MeshStandardMaterial({ color: bodyColor, roughness: 0.55 })
            );
            body.position.copy(pos);
            body.position.y = 0.9;
            body.castShadow = true;
            group.add(body);

            const head = new THREE.Mesh(
              new THREE.SphereGeometry(0.26, 16, 16),
              new THREE.MeshStandardMaterial({ color: headColor, roughness: 0.42, emissive: headColor, emissiveIntensity: 0.06 + intensity * 0.1 })
            );
            head.position.copy(pos);
            head.position.y = 1.52;
            head.castShadow = true;
            group.add(head);

            const label = new THREE.Sprite(
              new THREE.SpriteMaterial({ map: buildLabelTexture([
                `${pid} ${avatarId}`,
                `l=${pl.lives ?? 0} b=${pl.bankroll ?? 0}`,
                `bet=${pl.current_bet ?? 0} in=${pl.in_hand ? "Y" : "N"}`,
                `${dominant}=${Number(emoVal || 0).toFixed(2)}`,
              ]) })
            );
            label.scale.set(2.6, 1.35, 1);
            label.position.copy(pos);
            label.position.y = 2.55;
            group.add(label);

            const cards = Array.isArray(pl.hand) ? pl.hand.slice(0, 5) : [];
            if (cards.length) {
              cards.forEach((card, ci) => {
                const mesh = new THREE.Mesh(
                  new THREE.BoxGeometry(0.38, 0.52, 0.03),
                  [
                    new THREE.MeshStandardMaterial({ color: "#efe5d4" }),
                    new THREE.MeshStandardMaterial({ color: "#efe5d4" }),
                    new THREE.MeshStandardMaterial({ color: "#efe5d4" }),
                    new THREE.MeshStandardMaterial({ color: "#efe5d4" }),
                    new THREE.MeshStandardMaterial({ map: cardTexture(card), roughness: 0.6 }),
                    new THREE.MeshStandardMaterial({ color: "#d9cbb6" }),
                  ]
                );
                mesh.position.copy(pos);
                mesh.position.x += (ci - 2) * 0.30;
                mesh.position.y = 2.05;
                mesh.position.z += 0.62;
                mesh.rotation.x = -0.28;
                mesh.rotation.z = (ci - 2) * 0.03;
                mesh.castShadow = true;
                group.add(mesh);
              });
            }
          }
          const board = Array.isArray(t.communityCards) ? t.communityCards.slice(0, 5) : [];
          if (board.length) {
            board.forEach((card, bi) => {
              const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(0.46, 0.62, 0.035),
                [
                  new THREE.MeshStandardMaterial({ color: "#efe5d4" }),
                  new THREE.MeshStandardMaterial({ color: "#efe5d4" }),
                  new THREE.MeshStandardMaterial({ color: "#efe5d4" }),
                  new THREE.MeshStandardMaterial({ color: "#efe5d4" }),
                  new THREE.MeshStandardMaterial({ map: cardTexture(card), roughness: 0.6 }),
                  new THREE.MeshStandardMaterial({ color: "#d9cbb6" }),
                ]
              );
              mesh.position.set((bi - (board.length - 1) / 2) * 0.56, 0.83, 0);
              mesh.rotation.x = -0.2;
              mesh.castShadow = true;
              group.add(mesh);
            });
          }
          tableLayer.add(group);
        });
      });

      const rendered = list.length;
      const active = list.filter((t) => t.status === "active").length;
      el.summary.textContent = `tables=${rendered} active=${active} focus=${state.focusTable === "__all__" ? "all" : state.focusTable} live_only=${state.liveOnly ? "on" : "off"}`;
    }

    function renderTableList() {
      const rows = state.tables
        .filter((t) => !state.liveOnly || t.status === "active")
        .slice()
        .sort((a, b) => Number(b.stakeValue || 0) - Number(a.stakeValue || 0))
        .map((t) => {
          const pids = Object.keys(t.players).sort();
          const chips = `<span class="chips">stake ${Math.round(t.stakeValue)}</span>`;
          return `<div class="row">
            <div><strong>${t.gameId}</strong>${chips}</div>
            <div>status=${t.status} turn=${t.turn} phase=${t.phase}</div>
            <div>pot=${t.pot} ante=${t.ante} high_bet=${t.highBet} seats=${t.seatCount}</div>
            <div>players=${pids.join(",") || "-"}</div>
            <div>winners=${(t.winners || []).join(",") || "-"}</div>
          </div>`;
        })
        .join("");
      el.tables.innerHTML = rows || "<div>No games found.</div>";
    }

    function rebuildFocusOptions() {
      const current = state.focusTable;
      const options = ['<option value="__all__">All tables</option>']
        .concat(state.tables.map((t) => `<option value="${t.gameId}">${t.gameId}</option>`))
        .join("");
      el.focus.innerHTML = options;
      if (current && [...el.focus.options].some((o) => o.value === current)) {
        el.focus.value = current;
      } else {
        el.focus.value = "__all__";
        state.focusTable = "__all__";
      }
    }

    function setAuto(enabled) {
      state.auto = enabled;
      el.auto.textContent = `Auto: ${enabled ? "on" : "off"}`;
      if (state.autoTimer) {
        clearInterval(state.autoTimer);
        state.autoTimer = null;
      }
      if (enabled) {
        state.autoTimer = setInterval(loadArenaData, 2500);
      }
    }

    function resize() {
      renderer.setSize(el.stage.clientWidth, el.stage.clientHeight);
      camera.aspect = el.stage.clientWidth / el.stage.clientHeight;
      camera.updateProjectionMatrix();
    }

    el.refresh.addEventListener("click", loadArenaData);
    el.auto.addEventListener("click", () => setAuto(!state.auto));
    el.focus.addEventListener("change", () => {
      state.focusTable = el.focus.value;
      render3D();
    });
    el.liveOnly.addEventListener("change", () => {
      state.liveOnly = Boolean(el.liveOnly.checked);
      render3D();
      renderTableList();
    });
    el.scale.addEventListener("input", () => {
      state.worldScale = Number(el.scale.value || 110) / 100;
      render3D();
    });
    window.addEventListener("resize", resize);

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    setAuto(true);
    loadArenaData();
  </script>
</body>
</html>
