<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Damage 3D Arena Preview</title>
  <style>
    :root {
      --bg: #efe6da;
      --ink: #172621;
      --panel: #fff9ef;
      --line: #ccb9a3;
      --accent: #cf5a37;
      --muted: #58716b;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      color: var(--ink);
      font-family: "Space Grotesk", "Avenir Next", "Segoe UI", sans-serif;
      background:
        radial-gradient(circle at 12% 10%, #ffd3a6 0%, transparent 30%),
        radial-gradient(circle at 84% 8%, #a6ded5 0%, transparent 30%),
        var(--bg);
    }
    .wrap { max-width: 1400px; margin: 0 auto; padding: 14px; }
    .top {
      display: grid;
      grid-template-columns: 1fr auto auto auto auto auto auto auto auto;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
    }
    select, button, input[type="range"] {
      height: 38px;
      border-radius: 8px;
      border: 1px solid var(--line);
      font: inherit;
      padding: 0 10px;
      background: var(--panel);
      color: var(--ink);
    }
    button {
      cursor: pointer;
      border: none;
      color: #fff;
      background: linear-gradient(120deg, var(--accent), #e07b52);
    }
    .grid {
      display: grid;
      grid-template-columns: 1.6fr 1fr;
      gap: 12px;
    }
    .panel {
      border: 1px solid var(--line);
      border-radius: 12px;
      background: var(--panel);
      padding: 10px;
      min-height: 720px;
    }
    #stage {
      width: 100%;
      height: 700px;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid #d8c8b6;
      background: #ede7da;
    }
    .meta {
      font-family: "IBM Plex Mono", "Consolas", monospace;
      font-size: 12px;
      color: var(--muted);
      margin-top: 8px;
      display: grid;
      grid-template-columns: 1fr auto;
    }
    .list {
      height: 520px;
      overflow: auto;
      font-family: "IBM Plex Mono", "Consolas", monospace;
      font-size: 12px;
      border: 1px dashed var(--line);
      border-radius: 8px;
      padding: 8px;
      background: #fffdf8;
    }
    .bio-controls {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 8px;
      margin-top: 8px;
    }
    .bio {
      margin-top: 8px;
      height: 170px;
      overflow: auto;
      font-family: "IBM Plex Mono", "Consolas", monospace;
      font-size: 12px;
      border: 1px solid #e7dac7;
      border-radius: 8px;
      padding: 8px;
      background: #fffef9;
      white-space: pre-wrap;
      line-height: 1.35;
    }
    .row {
      border-bottom: 1px solid #f1e5d8;
      margin-bottom: 6px;
      padding-bottom: 6px;
    }
    .chips {
      display: inline-block;
      padding: 1px 6px;
      border-radius: 999px;
      background: #fde4be;
      color: #5f3902;
      margin-left: 4px;
    }
    .home {
      color: var(--muted);
      font-size: 12px;
      margin-left: 4px;
    }
    .fullscreen-active #stage {
      height: calc(100vh - 190px);
    }
    .fullscreen-active .list {
      height: calc(100vh - 190px);
    }
    .replaybar {
      display: grid;
      grid-template-columns: auto auto auto auto 1fr auto;
      gap: 8px;
      align-items: center;
      margin-bottom: 10px;
      font-family: "IBM Plex Mono", "Consolas", monospace;
      font-size: 12px;
      color: var(--muted);
    }
    .replaybar input[type="range"] {
      width: 100%;
    }
    @media (max-width: 1080px) {
      .top { grid-template-columns: 1fr 1fr; }
      .replaybar { grid-template-columns: 1fr 1fr; }
      .grid { grid-template-columns: 1fr; }
      .panel { min-height: 520px; }
      #stage { height: 500px; }
      .list { height: 340px; }
      .bio { height: 150px; }
    }
  </style>
  <script>
    window.addEventListener("error", (evt) => {
      const box = document.createElement("div");
      box.style.position = "fixed";
      box.style.left = "12px";
      box.style.bottom = "12px";
      box.style.zIndex = "9999";
      box.style.maxWidth = "70vw";
      box.style.padding = "10px 12px";
      box.style.borderRadius = "8px";
      box.style.border = "1px solid #d79d8f";
      box.style.background = "#fff1ed";
      box.style.color = "#6b1d0b";
      box.style.font = "12px monospace";
      box.textContent = `arena render error: ${evt.message || "unknown"}`;
      document.body.appendChild(box);
    });
  </script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.164.1/build/three.module.js"
      }
    }
  </script>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <select id="focus"></select>
      <button id="refresh">Refresh</button>
      <button id="replay">Load Replay</button>
      <button id="auto">Auto: on</button>
      <label><input id="liveOnly" type="checkbox"> Live Tables Only</label>
      <label>Scale <input id="scale" type="range" min="70" max="170" value="110"></label>
      <button id="prev">Prev</button>
      <button id="next">Next</button>
      <button id="play">Play</button>
      <button id="fullscreen">Fullscreen</button>
      <button id="toggleLog">Hide Log</button>
      <a class="home" href="/">dashboard</a>
    </div>
    <div class="replaybar">
      <span id="modeLabel">mode=live</span>
      <span id="cursorLabel">event 0 / 0</span>
      <label>speed</label>
      <input id="speed" type="range" min="1" max="8" value="4">
      <input id="cursor" type="range" min="0" max="0" value="0">
      <span id="speedLabel">1.00x</span>
    </div>
    <div class="grid">
      <div class="panel">
        <div id="stage"></div>
        <div class="meta">
          <span id="summary">loading...</span>
          <span>3D arena preview (stake pyramid)</span>
        </div>
      </div>
      <div class="panel">
        <div class="list" id="tables"></div>
        <div class="bio-controls">
          <select id="bioPlayer"></select>
          <button id="loadBio">Load Bio</button>
        </div>
        <div class="bio" id="bio">No bio loaded.</div>
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "https://unpkg.com/three@0.164.1/examples/jsm/controls/OrbitControls.js";

    const AVATAR_COLORS = {
      pilot_ace: "#d95f43",
      stoic_oracle: "#5984c7",
      bluff_knight: "#59a57a",
      cold_mirror: "#886cc5",
      trickster: "#cb8d34",
      iron_reader: "#48929a",
      quiet_storm: "#ce4f74",
      vector_hawk: "#6e8b3f",
      default: "#777f91"
    };

    const state = {
      tables: [],
      auto: true,
      autoTimer: null,
      focusTable: "__all__",
      worldScale: 1.1,
      liveOnly: false,
      mode: "live",
      replayEvents: [],
      replayGameId: "",
      replayCursor: 0,
      replayPlaying: false,
      replayTimer: null,
      logHidden: false
    };

    const el = {
      stage: document.getElementById("stage"),
      tables: document.getElementById("tables"),
      summary: document.getElementById("summary"),
      refresh: document.getElementById("refresh"),
      replay: document.getElementById("replay"),
      auto: document.getElementById("auto"),
      fullscreen: document.getElementById("fullscreen"),
      toggleLog: document.getElementById("toggleLog"),
      liveOnly: document.getElementById("liveOnly"),
      focus: document.getElementById("focus"),
      scale: document.getElementById("scale"),
      prev: document.getElementById("prev"),
      next: document.getElementById("next"),
      play: document.getElementById("play"),
      modeLabel: document.getElementById("modeLabel"),
      cursorLabel: document.getElementById("cursorLabel"),
      cursor: document.getElementById("cursor"),
      speed: document.getElementById("speed"),
      speedLabel: document.getElementById("speedLabel"),
      bioPlayer: document.getElementById("bioPlayer"),
      loadBio: document.getElementById("loadBio"),
      bio: document.getElementById("bio")
    };
    function setLogHidden(hidden) {
      state.logHidden = Boolean(hidden);
      const logPanel = el.tables.closest(".panel");
      if (logPanel) logPanel.style.display = state.logHidden ? "none" : "";
      el.toggleLog.textContent = state.logHidden ? "Show Log" : "Hide Log";
      resize();
    }

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(el.stage.clientWidth, el.stage.clientHeight);
    renderer.shadowMap.enabled = true;
    el.stage.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color("#ede7da");
    scene.fog = new THREE.Fog("#ede7da", 30, 90);

    const camera = new THREE.PerspectiveCamera(45, el.stage.clientWidth / el.stage.clientHeight, 0.1, 220);
    camera.position.set(12, 18, 24);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.maxDistance = 80;
    controls.minDistance = 8;
    controls.target.set(0, 2, 0);

    const hemi = new THREE.HemisphereLight("#fff5df", "#8ca7a1", 0.85);
    scene.add(hemi);
    const dir = new THREE.DirectionalLight("#fff9ec", 0.95);
    dir.position.set(10, 18, 6);
    dir.castShadow = true;
    scene.add(dir);

    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(140, 140, 1, 1),
      new THREE.MeshStandardMaterial({ color: "#d8cfbf", roughness: 0.95 })
    );
    floor.rotation.x = -Math.PI / 2;
    floor.receiveShadow = true;
    scene.add(floor);

    const tableLayer = new THREE.Group();
    scene.add(tableLayer);
    const cardTextureCache = new Map();
    const pulseRings = [];

    function dominantEmotion(em) {
      const base = em || {};
      const items = [
        ["fear", Number(base.fear || 0)],
        ["anger", Number(base.anger || 0)],
        ["shame", Number(base.shame || 0)],
        ["confidence", Number(base.confidence || 0)],
        ["tilt", Number(base.tilt || 0)],
      ];
      items.sort((a, b) => Math.abs(b[1]) - Math.abs(a[1]));
      return items[0];
    }

    function mapSeatCount(playerCount) {
      return playerCount <= 6 ? 6 : 8;
    }

    function parseGameEvents(gameId, events) {
      const table = {
        gameId,
        turn: 0,
        phase: "idle",
        ante: 10,
        pot: 0,
        highBet: 0,
        seatCount: 6,
        players: {},
        winners: [],
        status: "active",
        stakeValue: 10,
        cardStyle: "draw5",
        communityCards: [],
      };
      for (const evt of (events || [])) {
        const p = evt.payload || {};
        if (evt.type === "game_started") {
          table.seatCount = mapSeatCount(Number(p.players || 0));
        }
        if (typeof p.turn === "number") table.turn = p.turn;
        if (typeof p.card_style === "string") table.cardStyle = p.card_style;
        if (Array.isArray(p.community_cards)) table.communityCards = p.community_cards.slice();
        if (evt.type === "phase_changed") table.phase = String(p.phase || table.phase);
        if (evt.type === "hand_started") {
          table.ante = Number(p.ante || table.ante);
          table.pot = Number(p.pot || table.pot);
          for (const pl of (p.players || [])) {
            table.players[pl.player_id] = {
              ...(table.players[pl.player_id] || {}),
              ...pl,
              thinking: false,
              thought: (table.players[pl.player_id] || {}).thought || "",
              chatter: (table.players[pl.player_id] || {}).chatter || "",
              reaction: (table.players[pl.player_id] || {}).reaction || "",
              avatar_id: pl.avatar_id || (table.players[pl.player_id] || {}).avatar_id || "pilot_ace",
              backstory_summary: pl.backstory_summary || (table.players[pl.player_id] || {}).backstory_summary || "",
              backstory_file: pl.backstory_file || (table.players[pl.player_id] || {}).backstory_file || "",
            };
          }
        }
        if (evt.type === "player_joined" && p.player_state && p.player_id) {
          table.players[p.player_id] = {
            ...(table.players[p.player_id] || {}),
            ...p.player_state,
            thinking: false,
            thought: (table.players[p.player_id] || {}).thought || "",
            chatter: (table.players[p.player_id] || {}).chatter || "",
            reaction: (table.players[p.player_id] || {}).reaction || "",
            avatar_id: p.player_state.avatar_id || (table.players[p.player_id] || {}).avatar_id || "pilot_ace",
            backstory_summary: p.player_state.backstory_summary || (table.players[p.player_id] || {}).backstory_summary || "",
            backstory_file: p.player_state.backstory_file || (table.players[p.player_id] || {}).backstory_file || "",
          };
        }
        if (evt.type === "action_resolved" && p.player_state && p.player_id) {
          table.pot = Number(p.pot || table.pot);
          table.highBet = Number(p.current_high_bet || table.highBet);
          table.players[p.player_id] = {
            ...(table.players[p.player_id] || {}),
            ...p.player_state,
            thinking: (table.players[p.player_id] || {}).thinking || false,
            thought: (table.players[p.player_id] || {}).thought || "",
            chatter: (table.players[p.player_id] || {}).chatter || "",
            reaction: (table.players[p.player_id] || {}).reaction || "",
            avatar_id: p.player_state.avatar_id || (table.players[p.player_id] || {}).avatar_id || "pilot_ace",
          };
        }
        if (evt.type === "avatar_selected" && p.player_id) {
          table.players[p.player_id] = {
            ...(table.players[p.player_id] || { player_id: p.player_id }),
            avatar_id: String(p.avatar_id || "pilot_ace"),
            alias: String(p.alias || (table.players[p.player_id] || {}).alias || ""),
            self_geometry: String(p.self_geometry || (table.players[p.player_id] || {}).self_geometry || "hexagon"),
            self_symbol: String(p.self_symbol || (table.players[p.player_id] || {}).self_symbol || "star"),
          };
        }
        if (evt.type === "backstory_created" && p.player_id) {
          table.players[p.player_id] = {
            ...(table.players[p.player_id] || { player_id: p.player_id }),
            backstory_summary: String(p.summary || (table.players[p.player_id] || {}).backstory_summary || ""),
            backstory_file: String(p.file || (table.players[p.player_id] || {}).backstory_file || ""),
          };
        }
        if (evt.type === "thinking" && p.player_id) {
          table.players[p.player_id] = {
            ...(table.players[p.player_id] || { player_id: p.player_id }),
            thinking: p.status === "start",
            thought: typeof p.summary === "string" && p.summary.trim()
              ? p.summary.trim()
              : (table.players[p.player_id] || {}).thought || "",
            chatter: (table.players[p.player_id] || {}).chatter || "",
            reaction: (table.players[p.player_id] || {}).reaction || "",
          };
        }
        if (evt.type === "chatter_posted" && p.player_id) {
          table.players[p.player_id] = {
            ...(table.players[p.player_id] || { player_id: p.player_id }),
            chatter: String(p.message || "").trim().slice(0, 160),
            thought: (table.players[p.player_id] || {}).thought || "",
            reaction: (table.players[p.player_id] || {}).reaction || "",
            thinking: (table.players[p.player_id] || {}).thinking || false,
          };
        }
        if (evt.type === "chatter_evaluated" && p.target_player_id) {
          table.players[p.target_player_id] = {
            ...(table.players[p.target_player_id] || { player_id: p.target_player_id }),
            reaction: String(p.summary || "").trim().slice(0, 160),
            emotions: p.target_emotions || (table.players[p.target_player_id] || {}).emotions || {},
            thought: (table.players[p.target_player_id] || {}).thought || "",
            chatter: (table.players[p.target_player_id] || {}).chatter || "",
            thinking: (table.players[p.target_player_id] || {}).thinking || false,
          };
        }
        if (evt.type === "affect_resolved" && p.target_player_id && p.target_emotions) {
          table.players[p.target_player_id] = {
            ...(table.players[p.target_player_id] || { player_id: p.target_player_id }),
            emotions: p.target_emotions,
          };
        }
        if (evt.type === "direct_emoter_attack_resolved" && p.target_player_id && p.after) {
          table.players[p.target_player_id] = {
            ...(table.players[p.target_player_id] || { player_id: p.target_player_id }),
            emotions: p.after,
          };
        }
        if (evt.type === "showdown") {
          table.winners = Array.isArray(p.winners) ? p.winners : [];
          table.pot = Number(p.pot || table.pot);
        }
        if (evt.type === "hand_ended") {
          for (const pl of (p.players || [])) {
            table.players[pl.player_id] = {
              ...(table.players[pl.player_id] || {}),
              ...pl,
              thinking: (table.players[pl.player_id] || {}).thinking || false,
              thought: (table.players[pl.player_id] || {}).thought || "",
              chatter: (table.players[pl.player_id] || {}).chatter || "",
              reaction: (table.players[pl.player_id] || {}).reaction || "",
              avatar_id: pl.avatar_id || (table.players[pl.player_id] || {}).avatar_id || "pilot_ace",
              backstory_summary: pl.backstory_summary || (table.players[pl.player_id] || {}).backstory_summary || "",
              backstory_file: pl.backstory_file || (table.players[pl.player_id] || {}).backstory_file || "",
            };
          }
        }
        if (evt.type === "game_ended") {
          table.status = "ended";
          for (const pl of (p.final_state || [])) {
            table.players[pl.player_id] = {
              ...(table.players[pl.player_id] || {}),
              ...pl,
              avatar_id: pl.avatar_id || (table.players[pl.player_id] || {}).avatar_id || "pilot_ace",
              backstory_summary: pl.backstory_summary || (table.players[pl.player_id] || {}).backstory_summary || "",
              backstory_file: pl.backstory_file || (table.players[pl.player_id] || {}).backstory_file || "",
            };
          }
        }
      }
      const playersArr = Object.values(table.players);
      const playerCount = playersArr.length;
      if (playerCount > 0) {
        table.seatCount = mapSeatCount(playerCount);
      }
      const anteStake = Math.max(1, table.ante * Math.max(1, playerCount));
      table.stakeValue = Math.max(anteStake, table.pot, table.highBet * Math.max(1, playerCount), 10);
      return table;
    }

    async function loadArenaData() {
      const gamesRes = await fetch("/api/games");
      const gamesData = await gamesRes.json();
      const games = Array.isArray(gamesData.games) ? gamesData.games : [];
      const sliced = games.slice(0, 24);
      const replays = await Promise.all(
        sliced.map(async (g) => {
          try {
            const r = await fetch(`/api/replay?game_id=${encodeURIComponent(g.game_id)}`);
            const data = await r.json();
            return parseGameEvents(g.game_id, data.events || []);
          } catch {
            return null;
          }
        })
      );
      state.tables = replays.filter(Boolean);
      renderTableList();
      rebuildFocusOptions();
      if (state.mode === "replay" && state.replayGameId) {
        const found = state.tables.some((t) => t.gameId === state.replayGameId);
        if (!found) {
          stopReplayPlayback();
          state.mode = "live";
          state.replayEvents = [];
          state.replayGameId = "";
          state.replayCursor = 0;
        }
      }
      updateReplayHud();
      render3D();
    }

    function buildLabelTexture(lines) {
      const canvas = document.createElement("canvas");
      canvas.width = 256;
      canvas.height = 128;
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "rgba(255, 251, 240, 0.92)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "rgba(66, 50, 38, 0.45)";
      ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2);
      ctx.fillStyle = "#1c2d28";
      ctx.font = "18px monospace";
      for (let i = 0; i < lines.length; i++) {
        ctx.fillText(lines[i], 12, 26 + i * 22);
      }
      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;
      return tex;
    }

    function wrapText(text, maxChars) {
      const words = String(text || "").trim().split(/\s+/).filter(Boolean);
      if (!words.length) return [];
      const lines = [];
      let cur = "";
      for (const w of words) {
        const next = cur ? `${cur} ${w}` : w;
        if (next.length <= maxChars) cur = next;
        else {
          if (cur) lines.push(cur);
          cur = w;
        }
      }
      if (cur) lines.push(cur);
      return lines.slice(0, 3);
    }

    function parseCardCode(code) {
      const text = String(code || "").trim().toUpperCase();
      if (text.length < 2) return { rank: "?", suit: "?" };
      return { rank: text.slice(0, -1), suit: text.slice(-1) };
    }

    function suitVisual(suit) {
      if (suit === "H") return { symbol: "♥", color: "#c13f36" };
      if (suit === "D") return { symbol: "♦", color: "#cf5a37" };
      if (suit === "S") return { symbol: "♠", color: "#1f2d39" };
      return { symbol: "♣", color: "#1f5f41" };
    }

    function cardTexture(cardCode) {
      const key = String(cardCode || "??");
      if (cardTextureCache.has(key)) return cardTextureCache.get(key);
      const { rank, suit } = parseCardCode(key);
      const suitMeta = suitVisual(suit);
      const canvas = document.createElement("canvas");
      canvas.width = 160;
      canvas.height = 224;
      const ctx = canvas.getContext("2d");
      ctx.fillStyle = "#fffdf6";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "#d3c3ad";
      ctx.lineWidth = 5;
      ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
      ctx.fillStyle = suitMeta.color;
      ctx.font = "bold 38px monospace";
      ctx.fillText(rank, 14, 42);
      ctx.font = "bold 36px monospace";
      ctx.fillText(suitMeta.symbol, 18, 78);
      ctx.font = "bold 84px monospace";
      ctx.fillText(suitMeta.symbol, 56, 146);
      ctx.font = "bold 34px monospace";
      ctx.fillText(rank, canvas.width - 38, canvas.height - 16);
      const tex = new THREE.CanvasTexture(canvas);
      tex.needsUpdate = true;
      tex.anisotropy = 2;
      cardTextureCache.set(key, tex);
      return tex;
    }

    function seatPosition(index, total, radius) {
      const angle = (-Math.PI / 2) + (2 * Math.PI * index / Math.max(total, 1));
      return new THREE.Vector3(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
    }

    function allocateTierCounts(total, tierCount) {
      const t = Math.max(1, Math.min(total, tierCount));
      const weights = [];
      for (let i = 0; i < t; i++) {
        weights.push(Math.pow(2, t - 1 - i));
      }
      const sumW = weights.reduce((a, b) => a + b, 0);
      const counts = weights.map((w) => Math.max(1, Math.floor((w / sumW) * total)));
      let current = counts.reduce((a, b) => a + b, 0);
      while (current < total) {
        for (let i = 0; i < counts.length && current < total; i++) {
          counts[i] += 1;
          current += 1;
        }
      }
      while (current > total) {
        for (let i = counts.length - 1; i >= 0 && current > total; i--) {
          if (counts[i] > 1) {
            counts[i] -= 1;
            current -= 1;
          }
        }
      }
      return counts;
    }

    function render3D() {
      while (tableLayer.children.length) {
        const c = tableLayer.children.pop();
        c.traverse((node) => {
          if (node.geometry) node.geometry.dispose();
          if (node.material) {
            if (Array.isArray(node.material)) node.material.forEach((m) => m.dispose());
            else node.material.dispose();
          }
        });
      }
      pulseRings.length = 0;

      const list = state.tables.filter((t) => {
        if (state.liveOnly && t.status !== "active") return false;
        return state.focusTable === "__all__" || t.gameId === state.focusTable;
      });
      const sortedByStake = list
        .slice()
        .sort((a, b) => Number(a.stakeValue || 0) - Number(b.stakeValue || 0));
      const tierCount = Math.max(1, Math.min(5, Math.ceil(Math.log2(Math.max(2, sortedByStake.length)))));
      const tierCounts = allocateTierCounts(sortedByStake.length, tierCount);
      const tiers = [];
      let cursor = 0;
      for (let i = 0; i < tierCounts.length; i++) {
        const take = tierCounts[i];
        tiers.push(sortedByStake.slice(cursor, cursor + take));
        cursor += take;
      }
      const spacingX = 12 * state.worldScale;
      const spacingZ = 11 * state.worldScale;

      tiers.forEach((tierTables, tierIndex) => {
        const tierY = 0.5 + tierIndex * 1.8 * state.worldScale;
        const tierZ = (tiers.length - 1 - tierIndex) * spacingZ - ((tiers.length - 1) * spacingZ * 0.5);
        const cols = Math.max(1, Math.ceil(Math.sqrt(tierTables.length * 1.8)));
        const rows = Math.max(1, Math.ceil(tierTables.length / cols));
        tierTables.forEach((t, localIndex) => {
          const group = new THREE.Group();
          const col = localIndex % cols;
          const row = Math.floor(localIndex / cols);
          const centeredX = (col - (cols - 1) / 2) * spacingX;
          const centeredZ = tierZ + (row - (rows - 1) / 2) * (spacingZ * 0.7);
          group.position.set(centeredX, tierY, centeredZ);

          const tableBase = new THREE.Mesh(
            new THREE.CylinderGeometry(4.5, 5.0, 1.1, 36),
            new THREE.MeshStandardMaterial({ color: "#244e45", roughness: 0.65 })
          );
          tableBase.castShadow = true;
          group.add(tableBase);

          const felt = new THREE.Mesh(
            new THREE.CylinderGeometry(4.1, 4.1, 0.14, 32),
            new THREE.MeshStandardMaterial({ color: "#2f8d75", roughness: 0.75 })
          );
          felt.position.y = 0.62;
          group.add(felt);

          const infoSprite = new THREE.Sprite(
            new THREE.SpriteMaterial({ map: buildLabelTexture([
              t.gameId,
              `pot=${t.pot} ante=${t.ante}`,
              `turn=${t.turn} phase=${t.phase} style=${t.cardStyle}`,
              `tier=${tierIndex + 1}/${tiers.length} stake=${Math.round(t.stakeValue)}`,
            ]) })
          );
          infoSprite.scale.set(5.0, 2.5, 1);
          infoSprite.position.set(0, 3.6, 0);
          group.add(infoSprite);

          const ids = Object.keys(t.players).sort();
          for (let seat = 0; seat < t.seatCount; seat++) {
            const pos = seatPosition(seat, t.seatCount, 5.4);
            const chair = new THREE.Mesh(
              new THREE.CylinderGeometry(0.45, 0.45, 0.35, 20),
              new THREE.MeshStandardMaterial({ color: "#6b4a34", roughness: 0.85 })
            );
            chair.position.copy(pos);
            chair.position.y = 0.25;
            group.add(chair);

            const pid = ids[seat] || null;
            if (!pid) continue;
            const pl = t.players[pid] || {};
            const avatarId = String(pl.avatar_id || "pilot_ace");
            const bodyColor = AVATAR_COLORS[avatarId] || AVATAR_COLORS.default;
            const selfGeometry = String(pl.self_geometry || "hexagon");
            const selfSymbol = String(pl.self_symbol || "star");
            const [dominant, emoVal] = dominantEmotion(pl.emotions || {});
            const intensity = Math.max(0.15, Math.min(1.0, Math.abs(Number(emoVal || 0))));
            const avatarColor = dominant === "confidence" ? "#c7f0cc" :
              dominant === "anger" ? "#f0b4a8" :
              dominant === "fear" ? "#d8e5f0" :
              dominant === "tilt" ? "#f3d2a6" : "#e2d8f4";
            const beam = new THREE.Mesh(
              new THREE.CylinderGeometry(0.12, 0.12, 1.45, 24),
              new THREE.MeshStandardMaterial({
                color: bodyColor,
                emissive: bodyColor,
                emissiveIntensity: 0.18 + intensity * 0.22,
                transparent: true,
                opacity: 0.78,
                roughness: 0.2,
              })
            );
            beam.position.copy(pos);
            beam.position.y = 1.05;
            group.add(beam);

            let avatarGeo;
            if (selfGeometry === "circle") avatarGeo = new THREE.SphereGeometry(0.34, 20, 20);
            else if (selfGeometry === "triangle") avatarGeo = new THREE.ConeGeometry(0.36, 0.64, 3);
            else if (selfGeometry === "square") avatarGeo = new THREE.BoxGeometry(0.56, 0.56, 0.56);
            else if (selfGeometry === "diamond") avatarGeo = new THREE.OctahedronGeometry(0.34);
            else if (selfGeometry === "octagon") avatarGeo = new THREE.CylinderGeometry(0.30, 0.30, 0.56, 8);
            else avatarGeo = new THREE.CylinderGeometry(0.30, 0.30, 0.56, 6);

            const avatar = new THREE.Mesh(
              avatarGeo,
              new THREE.MeshStandardMaterial({
                color: avatarColor,
                roughness: 0.35,
                emissive: avatarColor,
                emissiveIntensity: 0.08 + intensity * 0.15,
              })
            );
            avatar.position.copy(pos);
            avatar.position.y = 1.78;
            avatar.castShadow = true;
            group.add(avatar);
            if (selfGeometry === "triangle") avatar.rotation.y = Math.PI / 6;

            const symbolBadge = new THREE.Sprite(
              new THREE.SpriteMaterial({ map: buildLabelTexture([selfSymbol.toUpperCase()]) })
            );
            symbolBadge.scale.set(0.95, 0.44, 1);
            symbolBadge.position.copy(pos);
            symbolBadge.position.y = 2.3;
            group.add(symbolBadge);
            if (pl.thinking) {
              const ring = new THREE.Mesh(
                new THREE.TorusGeometry(0.36, 0.035, 10, 28),
                new THREE.MeshStandardMaterial({
                  color: "#ffd49a",
                  emissive: "#f5a74f",
                  emissiveIntensity: 0.5,
                  transparent: true,
                  opacity: 0.95,
                })
              );
              ring.position.copy(pos);
              ring.position.y = 1.78;
              ring.rotation.x = Math.PI / 2;
              ring.userData.pulsePhase = Math.random() * Math.PI * 2;
              group.add(ring);
              pulseRings.push(ring);
            }

            const label = new THREE.Sprite(
              new THREE.SpriteMaterial({ map: buildLabelTexture([
                `${pl.alias ? `${pl.alias}(${pid})` : pid} ${avatarId}`,
                `motif=${selfGeometry}/${selfSymbol}`,
                `l=${pl.lives ?? 0} b=${pl.bankroll ?? 0}`,
                `bet=${pl.current_bet ?? 0} in=${pl.in_hand ? "Y" : "N"}`,
                `${dominant}=${Number(emoVal || 0).toFixed(2)}`,
              ]) })
            );
            label.scale.set(2.6, 1.35, 1);
            label.position.copy(pos);
            label.position.y = 2.55;
            group.add(label);
            const bubbleText = pl.chatter || pl.thought || pl.reaction || "";
            if (bubbleText) {
              const lines = wrapText(bubbleText, 22);
              const bubble = new THREE.Sprite(
                new THREE.SpriteMaterial({ map: buildLabelTexture(lines.length ? lines : [bubbleText.slice(0, 22)]) })
              );
              bubble.scale.set(3.2, 1.5, 1);
              bubble.position.copy(pos);
              bubble.position.y = 3.7;
              group.add(bubble);
            }

            const cards = Array.isArray(pl.hand) ? pl.hand.slice(0, 5) : [];
            if (cards.length) {
              cards.forEach((card, ci) => {
                const mesh = new THREE.Mesh(
                  new THREE.BoxGeometry(0.38, 0.52, 0.03),
                  [
                    new THREE.MeshStandardMaterial({ color: "#efe5d4" }),
                    new THREE.MeshStandardMaterial({ color: "#efe5d4" }),
                    new THREE.MeshStandardMaterial({ color: "#efe5d4" }),
                    new THREE.MeshStandardMaterial({ color: "#efe5d4" }),
                    new THREE.MeshStandardMaterial({ map: cardTexture(card), roughness: 0.6 }),
                    new THREE.MeshStandardMaterial({ color: "#d9cbb6" }),
                  ]
                );
                mesh.position.copy(pos);
                mesh.position.x += (ci - 2) * 0.30;
                mesh.position.y = 2.05;
                mesh.position.z += 0.62;
                mesh.rotation.x = -0.28;
                mesh.rotation.z = (ci - 2) * 0.03;
                mesh.castShadow = true;
                group.add(mesh);
              });
            }
          }
          const board = Array.isArray(t.communityCards) ? t.communityCards.slice(0, 5) : [];
          if (board.length) {
            board.forEach((card, bi) => {
              const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(0.46, 0.62, 0.035),
                [
                  new THREE.MeshStandardMaterial({ color: "#efe5d4" }),
                  new THREE.MeshStandardMaterial({ color: "#efe5d4" }),
                  new THREE.MeshStandardMaterial({ color: "#efe5d4" }),
                  new THREE.MeshStandardMaterial({ color: "#efe5d4" }),
                  new THREE.MeshStandardMaterial({ map: cardTexture(card), roughness: 0.6 }),
                  new THREE.MeshStandardMaterial({ color: "#d9cbb6" }),
                ]
              );
              mesh.position.set((bi - (board.length - 1) / 2) * 0.56, 0.83, 0);
              mesh.rotation.x = -0.2;
              mesh.castShadow = true;
              group.add(mesh);
            });
          }
          tableLayer.add(group);
        });
      });

      const rendered = list.length;
      const active = list.filter((t) => t.status === "active").length;
      el.summary.textContent = `tables=${rendered} active=${active} focus=${state.focusTable === "__all__" ? "all" : state.focusTable} live_only=${state.liveOnly ? "on" : "off"}`;
    }

    function renderTableList() {
      const rows = state.tables
        .filter((t) => !state.liveOnly || t.status === "active")
        .slice()
        .sort((a, b) => Number(b.stakeValue || 0) - Number(a.stakeValue || 0))
        .map((t) => {
          const pids = Object.keys(t.players).sort();
          const labeled = pids.map((pid) => {
            const p = t.players[pid] || {};
            const motif = `${String(p.self_geometry || "hexagon")[0]}:${String(p.self_symbol || "star")[0]}`;
            const base = p.alias ? `${p.alias}(${pid})` : pid;
            return `${base}[${motif}]`;
          });
          const chips = `<span class="chips">stake ${Math.round(t.stakeValue)}</span>`;
          return `<div class="row">
            <div><strong>${t.gameId}</strong>${chips}</div>
            <div>status=${t.status} turn=${t.turn} phase=${t.phase}</div>
            <div>pot=${t.pot} ante=${t.ante} high_bet=${t.highBet} seats=${t.seatCount}</div>
            <div>players=${labeled.join(",") || "-"}</div>
            <div>winners=${(t.winners || []).join(",") || "-"}</div>
          </div>`;
        })
        .join("");
      el.tables.innerHTML = rows || "<div>No games found.</div>";
      refreshBioPlayers();
    }

    function currentBioGameId() {
      if (state.focusTable !== "__all__") return state.focusTable;
      if (state.mode === "replay" && state.replayGameId) return state.replayGameId;
      const first = state.tables[0];
      return first ? first.gameId : "";
    }

    function refreshBioPlayers() {
      const gid = currentBioGameId();
      const table = state.tables.find((t) => t.gameId === gid);
      const ids = table ? Object.keys(table.players || {}).sort() : [];
      el.bioPlayer.innerHTML = ids.map((pid) => {
        const p = table.players[pid] || {};
        const name = p.alias ? `${p.alias} (${pid})` : pid;
        return `<option value="${pid}">${name}</option>`;
      }).join("");
    }

    async function loadBio() {
      const gid = currentBioGameId();
      const pid = el.bioPlayer.value;
      if (!gid || !pid) {
        el.bio.textContent = "No bio loaded.";
        return;
      }
      const r = await fetch(`/api/bio?game_id=${encodeURIComponent(gid)}&player_id=${encodeURIComponent(pid)}`);
      if (!r.ok) {
        el.bio.textContent = `Bio unavailable for ${pid}`;
        return;
      }
      const data = await r.json();
      el.bio.textContent = data.markdown || "Bio unavailable.";
    }

    function rebuildFocusOptions() {
      const current = state.focusTable;
      const options = ['<option value="__all__">All tables</option>']
        .concat(state.tables.map((t) => `<option value="${t.gameId}">${t.gameId}</option>`))
        .join("");
      el.focus.innerHTML = options;
      if (current && [...el.focus.options].some((o) => o.value === current)) {
        el.focus.value = current;
      } else {
        el.focus.value = "__all__";
        state.focusTable = "__all__";
      }
    }

    function setAuto(enabled) {
      state.auto = enabled;
      el.auto.textContent = `Auto: ${enabled ? "on" : "off"}`;
      if (state.autoTimer) {
        clearInterval(state.autoTimer);
        state.autoTimer = null;
      }
      if (enabled) {
        state.autoTimer = setInterval(loadArenaData, 2500);
      }
    }

    function replaySpeed() {
      const raw = Number(el.speed.value || 4);
      const mapped = [0.25, 0.5, 0.75, 1.0, 1.5, 2.0, 3.0, 4.0];
      return mapped[Math.max(0, Math.min(mapped.length - 1, raw - 1))];
    }

    function updateReplayHud() {
      el.modeLabel.textContent = `mode=${state.mode}${state.replayGameId ? ` game=${state.replayGameId}` : ""}`;
      el.cursor.max = String(Math.max(0, state.replayEvents.length));
      el.cursor.value = String(state.replayCursor);
      el.cursorLabel.textContent = `event ${state.replayCursor} / ${state.replayEvents.length}`;
      el.speedLabel.textContent = `${replaySpeed().toFixed(2)}x`;
      el.play.textContent = state.replayPlaying ? "Pause" : "Play";
    }

    function stopReplayPlayback() {
      state.replayPlaying = false;
      if (state.replayTimer) {
        clearInterval(state.replayTimer);
        state.replayTimer = null;
      }
    }

    function seekReplay(cursor) {
      if (!state.replayGameId || !state.replayEvents.length) return;
      const clamped = Math.max(0, Math.min(cursor, state.replayEvents.length));
      state.replayCursor = clamped;
      const table = parseGameEvents(state.replayGameId, state.replayEvents.slice(0, clamped));
      const idx = state.tables.findIndex((t) => t.gameId === state.replayGameId);
      if (idx >= 0) state.tables[idx] = table;
      else state.tables.push(table);
      updateReplayHud();
      renderTableList();
      render3D();
    }

    function startReplayPlayback() {
      if (state.replayPlaying || !state.replayEvents.length) return;
      state.replayPlaying = true;
      const delayMs = Math.max(70, Math.floor(450 / replaySpeed()));
      state.replayTimer = setInterval(() => {
        if (state.replayCursor >= state.replayEvents.length) {
          stopReplayPlayback();
          updateReplayHud();
          return;
        }
        seekReplay(state.replayCursor + 1);
      }, delayMs);
      updateReplayHud();
    }

    function pickReplayGameId() {
      if (state.focusTable !== "__all__") return state.focusTable;
      const filtered = state.tables.filter((t) => !state.liveOnly || t.status === "active");
      if (!filtered.length) return "";
      filtered.sort((a, b) => Number(b.stakeValue || 0) - Number(a.stakeValue || 0));
      return filtered[0].gameId;
    }

    async function loadReplayForFocus() {
      const gameId = pickReplayGameId();
      if (!gameId) return;
      stopReplayPlayback();
      const r = await fetch(`/api/replay?game_id=${encodeURIComponent(gameId)}`);
      const data = await r.json();
      state.mode = "replay";
      state.replayGameId = gameId;
      state.replayEvents = Array.isArray(data.events) ? data.events : [];
      state.replayCursor = 0;
      seekReplay(state.replayEvents.length);
      updateReplayHud();
    }

    function resize() {
      renderer.setSize(el.stage.clientWidth, el.stage.clientHeight);
      camera.aspect = el.stage.clientWidth / el.stage.clientHeight;
      camera.updateProjectionMatrix();
    }

    el.refresh.addEventListener("click", loadArenaData);
    el.replay.addEventListener("click", loadReplayForFocus);
    el.auto.addEventListener("click", () => setAuto(!state.auto));
    el.focus.addEventListener("change", () => {
      state.focusTable = el.focus.value;
      refreshBioPlayers();
      render3D();
    });
    el.prev.addEventListener("click", () => {
      stopReplayPlayback();
      seekReplay(state.replayCursor - 1);
    });
    el.next.addEventListener("click", () => {
      stopReplayPlayback();
      seekReplay(state.replayCursor + 1);
    });
    el.play.addEventListener("click", () => {
      if (state.replayPlaying) stopReplayPlayback();
      else startReplayPlayback();
      updateReplayHud();
    });
    el.fullscreen.addEventListener("click", async () => {
      if (!document.fullscreenElement) {
        await document.documentElement.requestFullscreen();
      } else {
        await document.exitFullscreen();
      }
    });
    el.toggleLog.addEventListener("click", () => {
      setLogHidden(!state.logHidden);
    });
    el.cursor.addEventListener("input", () => {
      stopReplayPlayback();
      seekReplay(Number(el.cursor.value));
    });
    el.speed.addEventListener("input", () => {
      if (state.replayPlaying) {
        stopReplayPlayback();
        startReplayPlayback();
      }
      updateReplayHud();
    });
    el.loadBio.addEventListener("click", loadBio);
    el.liveOnly.addEventListener("change", () => {
      state.liveOnly = Boolean(el.liveOnly.checked);
      render3D();
      renderTableList();
    });
    el.scale.addEventListener("input", () => {
      state.worldScale = Number(el.scale.value || 110) / 100;
      render3D();
    });
    window.addEventListener("resize", resize);
    document.addEventListener("fullscreenchange", () => {
      document.body.classList.toggle("fullscreen-active", Boolean(document.fullscreenElement));
      resize();
    });

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      const now = performance.now() * 0.004;
      for (const ring of pulseRings) {
        const phase = Number(ring.userData.pulsePhase || 0);
        const k = 0.88 + 0.18 * (0.5 + 0.5 * Math.sin(now + phase));
        ring.scale.set(k, k, k);
        if (ring.material && "opacity" in ring.material) {
          ring.material.opacity = 0.65 + 0.3 * (0.5 + 0.5 * Math.sin(now + phase));
        }
      }
      renderer.render(scene, camera);
    }
    animate();

    setAuto(true);
    loadArenaData();
    updateReplayHud();
  </script>
</body>
</html>
